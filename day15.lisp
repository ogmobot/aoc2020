;; Naive implementation is good enough for part 1.
;; Looks pretty elegant, too, imho.
;; The structure of a cons means insertion is O(1),
;; but lookup is O(n), and O(n^2) isn't good enough
;; for part 2.

(defun extend-list (nums)
  (let ((pos (position (car nums) (cdr nums))))
    (cons (if pos (+ pos 1) 0) nums)))

(defun apply-multiple (func n args)
  (let ((x args))
    (loop for i from 1 upto n
      do (setf x (funcall func x)))
    x))

;; So, let's do hash tables! This is effectively
;; O(1) insertion and O(1) lookup, so the function
;; runs in O(n). Part 2 still takes ages (~7s),
;; about 1s of which is garbage collection due to
;; the garbage generated by cons-ing new entries.
;; Profiling reveals the bottleneck is gethash.
;; So how can we improve on this?

(defun get-nth-element (nums n) ; don't reverse this list
  (let ((last-seen (make-hash-table))
        (time-index 0)
        (prev-n 0))
    ; populate initial table
    (loop
      for num in nums
      do (setf (gethash num last-seen) (cons time-index nil)) ; assumes members are unique
      do (setf prev-n num)
      do (incf time-index 1))
    ; do the thing
    (loop
      while (< time-index n)
      do (let ((next-n 0)
                (last-entry (gethash prev-n last-seen)))
            (if (cdr last-entry) (setf next-n (- (car last-entry) (cdr last-entry))))
            (setf (gethash next-n last-seen) (cons time-index (if (gethash next-n last-seen) (car (gethash next-n last-seen)) nil)))
            (setf prev-n next-n))
      do (incf time-index 1))
    prev-n))

;; The answer is arrays. Using the inherent O(1)
;; insertion and lookup without calling gethash,
;; plus some aggressive optimising from the compiler,
;; gets us down to ~1.5s. Nice!
;; (Downside: requires ~480 MB of memory to store the array!)

(declaim (ftype (function (list fixnum) fixnum) get-nth-element-vector))

(defun get-nth-element-vector (nums n)
    (declare (optimize (speed 3) (safety 0)))
    (let ((last-seen (make-array `(,n 2) :element-type 'fixnum :initial-element -1))
          (time-index 0)
          (prev-n 0))
        (declare (fixnum time-index prev-n))
        ; populate initial table
        (loop
            for num in nums
            do (setf
                (aref last-seen num 0) -1
                (aref last-seen num 1) time-index
                prev-n num
                time-index (+ 1 time-index)))
        ; do the thing
        (loop
            while (< time-index n)
            do (let ((next-n 0))
                (declare (fixnum next-n))
                (if (= -1 (aref last-seen prev-n 0))
                    (setf next-n 0)
                    (setf next-n (- (aref last-seen prev-n 1) (aref last-seen prev-n 0))))
                (setf
                    (aref last-seen next-n 0) (aref last-seen next-n 1)
                    (aref last-seen next-n 1) time-index
                    prev-n next-n
                    time-index (+ 1 time-index))))
        prev-n))

;(require :sb-sprof)
;(sb-sprof:with-profiling (:max-samples 100 :report :flat :loop t)

(let ((starting-list '(15 5 1 4 7 0)))
    ; part 1
    (format t "~a~%"
        (get-nth-element-vector starting-list 2020))
    ; part 2
    (format t "~a~%"
        (get-nth-element-vector starting-list 30000000)))

;)
